name: Infrastructure Setup

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - stage
        - prod
      action:
        description: 'Action to perform'
        required: true
        default: 'create'
        type: choice
        options:
        - create
        - update
        - destroy

env:
  AWS_REGION: ap-south-1
  HOSTED_ZONE_ID: ${{ secrets.HOSTED_ZONE_ID }}  # You need to add this secret

jobs:
  setup-infrastructure:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    outputs:
      db_endpoint: ${{ steps.database.outputs.endpoint }}
      db_password: ${{ steps.database.outputs.password }}
      alb_dns: ${{ steps.alb.outputs.dns_name }}
      backend_dns: ${{ steps.dns.outputs.backend_dns }}
      frontend_dns: ${{ steps.dns.outputs.frontend_dns }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set environment variables
      run: |
        echo "ENV_NAME=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        echo "DB_IDENTIFIER=sabpaisa-tokenization-${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        echo "ALB_NAME=sabpaisa-tokenization-alb-${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        echo "BACKEND_DNS=tokenization-${{ github.event.inputs.environment }}.api.sabpaisa.in" >> $GITHUB_ENV
        echo "FRONTEND_DNS=tokenization-${{ github.event.inputs.environment }}.sabpaisa.in" >> $GITHUB_ENV
        
    - name: Setup Database
      id: database
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸ—„ï¸ Setting up RDS Database"
        echo "=========================="
        
        # Check if DB already exists
        DB_EXISTS=$(aws rds describe-db-instances \
          --db-instance-identifier $DB_IDENTIFIER \
          --query 'DBInstances[0].DBInstanceIdentifier' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$DB_EXISTS" == "NOT_FOUND" ]]; then
          echo "Creating new RDS instance..."
          
          # Generate secure password
          DB_PASSWORD=$(openssl rand -base64 32 | tr -d "/@\" | cut -c1-25)
          
          # Create DB subnet group
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
          SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output text)
          
          aws rds create-db-subnet-group \
            --db-subnet-group-name ${DB_IDENTIFIER}-subnet-group \
            --db-subnet-group-description "Subnet group for $DB_IDENTIFIER" \
            --subnet-ids $SUBNETS 2>/dev/null || echo "Subnet group exists"
          
          # Create security group for RDS
          SG_ID=$(aws ec2 create-security-group \
            --group-name ${DB_IDENTIFIER}-sg \
            --description "Security group for $DB_IDENTIFIER" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text 2>/dev/null || \
            aws ec2 describe-security-groups \
              --filters "Name=group-name,Values=${DB_IDENTIFIER}-sg" \
              --query 'SecurityGroups[0].GroupId' \
              --output text)
          
          # Allow PostgreSQL access
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 2>/dev/null || echo "Rule exists"
          
          # Create RDS instance
          aws rds create-db-instance \
            --db-instance-identifier $DB_IDENTIFIER \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --allocated-storage 20 \
            --db-subnet-group-name ${DB_IDENTIFIER}-subnet-group \
            --vpc-security-group-ids $SG_ID \
            --publicly-accessible \
            --backup-retention-period 7 \
            --no-multi-az \
            --storage-encrypted
          
          echo "Waiting for database to be available..."
          aws rds wait db-instance-available --db-instance-identifier $DB_IDENTIFIER
          
          # Store password in Secrets Manager
          aws secretsmanager create-secret \
            --name ${DB_IDENTIFIER}-password \
            --secret-string "$DB_PASSWORD" 2>/dev/null || \
          aws secretsmanager update-secret \
            --secret-id ${DB_IDENTIFIER}-password \
            --secret-string "$DB_PASSWORD"
          
          echo "password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        else
          echo "Database already exists"
          # Retrieve password from Secrets Manager
          DB_PASSWORD=$(aws secretsmanager get-secret-value \
            --secret-id ${DB_IDENTIFIER}-password \
            --query 'SecretString' \
            --output text)
          echo "password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        fi
        
        # Get database endpoint
        DB_ENDPOINT=$(aws rds describe-db-instances \
          --db-instance-identifier $DB_IDENTIFIER \
          --query 'DBInstances[0].Endpoint.Address' \
          --output text)
        
        echo "endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
        echo "Database endpoint: $DB_ENDPOINT"
        
    - name: Setup Application Load Balancer
      id: alb
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸ”„ Setting up Application Load Balancer"
        echo "======================================"
        
        # Get VPC and subnets
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
        SUBNET_IDS=$(aws ec2 describe-subnets \
          --filters "Name=vpc-id,Values=$VPC_ID" \
          --query 'Subnets[?AvailabilityZone != `null`].SubnetId' \
          --output text | tr '\t' ' ')
        
        # Check if ALB exists
        ALB_EXISTS=$(aws elbv2 describe-load-balancers \
          --names $ALB_NAME \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$ALB_EXISTS" == "NOT_FOUND" ]]; then
          echo "Creating new ALB..."
          
          # Create security group for ALB
          ALB_SG_ID=$(aws ec2 create-security-group \
            --group-name ${ALB_NAME}-sg \
            --description "Security group for $ALB_NAME" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          
          # Allow HTTP/HTTPS traffic
          aws ec2 authorize-security-group-ingress \
            --group-id $ALB_SG_ID \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0
          
          aws ec2 authorize-security-group-ingress \
            --group-id $ALB_SG_ID \
            --protocol tcp \
            --port 443 \
            --cidr 0.0.0.0/0 2>/dev/null || true
          
          # Create ALB
          ALB_ARN=$(aws elbv2 create-load-balancer \
            --name $ALB_NAME \
            --subnets $SUBNET_IDS \
            --security-groups $ALB_SG_ID \
            --scheme internet-facing \
            --type application \
            --ip-address-type ipv4 \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text)
          
          # Create target groups
          # Backend target group
          BACKEND_TG_ARN=$(aws elbv2 create-target-group \
            --name ${ENV_NAME}-backend-tg \
            --protocol HTTP \
            --port 8082 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-path / \
            --health-check-interval-seconds 30 \
            --health-check-timeout-seconds 10 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 3 \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          # Frontend target group
          FRONTEND_TG_ARN=$(aws elbv2 create-target-group \
            --name ${ENV_NAME}-frontend-tg \
            --protocol HTTP \
            --port 3000 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-path / \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          # Create HTTP listener with rules
          LISTENER_ARN=$(aws elbv2 create-listener \
            --load-balancer-arn $ALB_ARN \
            --protocol HTTP \
            --port 80 \
            --default-actions Type=fixed-response,FixedResponseConfig={StatusCode=404} \
            --query 'Listeners[0].ListenerArn' \
            --output text)
          
          # Add rule for backend
          aws elbv2 create-rule \
            --listener-arn $LISTENER_ARN \
            --priority 1 \
            --conditions Field=host-header,Values=$BACKEND_DNS \
            --actions Type=forward,TargetGroupArn=$BACKEND_TG_ARN
          
          # Add rule for frontend
          aws elbv2 create-rule \
            --listener-arn $LISTENER_ARN \
            --priority 2 \
            --conditions Field=host-header,Values=$FRONTEND_DNS \
            --actions Type=forward,TargetGroupArn=$FRONTEND_TG_ARN
          
          # Store target group ARNs in parameter store
          aws ssm put-parameter \
            --name /${ENV_NAME}/backend/target-group-arn \
            --value $BACKEND_TG_ARN \
            --type String \
            --overwrite
          
          aws ssm put-parameter \
            --name /${ENV_NAME}/frontend/target-group-arn \
            --value $FRONTEND_TG_ARN \
            --type String \
            --overwrite
        fi
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names $ALB_NAME \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "dns_name=$ALB_DNS" >> $GITHUB_OUTPUT
        echo "ALB DNS: $ALB_DNS"
        
    - name: Configure Route53 DNS
      id: dns
      if: github.event.inputs.action != 'destroy' && env.HOSTED_ZONE_ID != ''
      run: |
        echo "ðŸŒ Configuring Route53 DNS"
        echo "========================="
        
        ALB_DNS="${{ steps.alb.outputs.dns_name }}"
        
        # Create/Update backend DNS record
        cat > /tmp/backend-dns-record.json <<EOF
        {
          "Changes": [{
            "Action": "UPSERT",
            "ResourceRecordSet": {
              "Name": "$BACKEND_DNS",
              "Type": "CNAME",
              "TTL": 300,
              "ResourceRecords": [{"Value": "$ALB_DNS"}]
            }
          }]
        }
        EOF
        
        aws route53 change-resource-record-sets \
          --hosted-zone-id $HOSTED_ZONE_ID \
          --change-batch file:///tmp/backend-dns-record.json
        
        # Create/Update frontend DNS record
        cat > /tmp/frontend-dns-record.json <<EOF
        {
          "Changes": [{
            "Action": "UPSERT",
            "ResourceRecordSet": {
              "Name": "$FRONTEND_DNS",
              "Type": "CNAME",
              "TTL": 300,
              "ResourceRecords": [{"Value": "$ALB_DNS"}]
            }
          }]
        }
        EOF
        
        aws route53 change-resource-record-sets \
          --hosted-zone-id $HOSTED_ZONE_ID \
          --change-batch file:///tmp/frontend-dns-record.json
        
        echo "backend_dns=$BACKEND_DNS" >> $GITHUB_OUTPUT
        echo "frontend_dns=$FRONTEND_DNS" >> $GITHUB_OUTPUT
        
        echo "âœ… DNS Configuration Complete"
        echo "Backend URL: http://$BACKEND_DNS"
        echo "Frontend URL: http://$FRONTEND_DNS"
        
    - name: Store Infrastructure Details
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸ’¾ Storing Infrastructure Details"
        echo "================================"
        
        # Store all infrastructure details in Parameter Store
        aws ssm put-parameter \
          --name /${ENV_NAME}/database/endpoint \
          --value "${{ steps.database.outputs.endpoint }}" \
          --type String \
          --overwrite
        
        aws ssm put-parameter \
          --name /${ENV_NAME}/alb/dns \
          --value "${{ steps.alb.outputs.dns_name }}" \
          --type String \
          --overwrite
        
        aws ssm put-parameter \
          --name /${ENV_NAME}/backend/url \
          --value "$BACKEND_DNS" \
          --type String \
          --overwrite
        
        aws ssm put-parameter \
          --name /${ENV_NAME}/frontend/url \
          --value "$FRONTEND_DNS" \
          --type String \
          --overwrite
        
        echo "âœ… Infrastructure setup complete!"
        
    - name: Cleanup Infrastructure
      if: github.event.inputs.action == 'destroy'
      run: |
        echo "ðŸ—‘ï¸ Destroying Infrastructure"
        echo "==========================="
        
        # Delete RDS instance
        aws rds delete-db-instance \
          --db-instance-identifier $DB_IDENTIFIER \
          --skip-final-snapshot \
          --delete-automated-backups 2>/dev/null || echo "Database not found"
        
        # Delete ALB
        ALB_ARN=$(aws elbv2 describe-load-balancers \
          --names $ALB_NAME \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$ALB_ARN" != "NOT_FOUND" ]]; then
          aws elbv2 delete-load-balancer --load-balancer-arn $ALB_ARN
        fi
        
        # Delete parameters
        aws ssm delete-parameter --name /${ENV_NAME}/database/endpoint 2>/dev/null || true
        aws ssm delete-parameter --name /${ENV_NAME}/backend/target-group-arn 2>/dev/null || true
        aws ssm delete-parameter --name /${ENV_NAME}/frontend/target-group-arn 2>/dev/null || true
        
        echo "âœ… Cleanup complete"