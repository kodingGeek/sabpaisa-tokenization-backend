name: Infrastructure Setup

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - stage
        - prod
      action:
        description: 'Action to perform'
        required: true
        default: 'create'
        type: choice
        options:
        - create
        - update
        - destroy

env:
  AWS_REGION: ap-south-1

jobs:
  setup-infrastructure:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    outputs:
      db_endpoint: ${{ steps.database.outputs.endpoint }}
      db_password: ${{ steps.database.outputs.password }}
      alb_dns: ${{ steps.alb.outputs.dns_name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set environment variables
      run: |
        echo "ENV_NAME=${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        echo "DB_IDENTIFIER=sabpaisa-tokenization-${{ github.event.inputs.environment }}" >> $GITHUB_ENV
        echo "ALB_NAME=sabpaisa-token-api-${{ github.event.inputs.environment }}-alb" >> $GITHUB_ENV
        
    - name: Setup Database
      id: database
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸ—„ï¸ Setting up RDS Database"
        echo "=========================="
        
        # Check if DB already exists
        DB_EXISTS=$(aws rds describe-db-instances \
          --db-instance-identifier $DB_IDENTIFIER \
          --query 'DBInstances[0].DBInstanceIdentifier' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$DB_EXISTS" == "NOT_FOUND" ]]; then
          echo "Creating new RDS instance..."
          
          # Generate secure password
          DB_PASSWORD=$(openssl rand -base64 32 | tr -d "/@\\\\" | cut -c1-25)
          
          # Create DB subnet group
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
          SUBNETS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output text)
          
          aws rds create-db-subnet-group \
            --db-subnet-group-name ${DB_IDENTIFIER}-subnet-group \
            --db-subnet-group-description "Subnet group for $DB_IDENTIFIER" \
            --subnet-ids $SUBNETS 2>/dev/null || echo "Subnet group exists"
          
          # Create security group for RDS
          SG_ID=$(aws ec2 create-security-group \
            --group-name ${DB_IDENTIFIER}-sg \
            --description "Security group for $DB_IDENTIFIER" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text 2>/dev/null || \
            aws ec2 describe-security-groups \
              --filters "Name=group-name,Values=${DB_IDENTIFIER}-sg" \
              --query 'SecurityGroups[0].GroupId' \
              --output text)
          
          # Allow PostgreSQL access
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 5432 \
            --cidr 0.0.0.0/0 2>/dev/null || echo "Rule exists"
          
          # Create RDS instance
          aws rds create-db-instance \
            --db-instance-identifier $DB_IDENTIFIER \
            --db-instance-class db.t3.micro \
            --engine postgres \
            --master-username postgres \
            --master-user-password "$DB_PASSWORD" \
            --allocated-storage 20 \
            --db-subnet-group-name ${DB_IDENTIFIER}-subnet-group \
            --vpc-security-group-ids $SG_ID \
            --publicly-accessible \
            --backup-retention-period 7 \
            --no-multi-az \
            --storage-encrypted
          
          echo "Waiting for database to be available..."
          aws rds wait db-instance-available --db-instance-identifier $DB_IDENTIFIER
          
          # Store password in Secrets Manager
          aws secretsmanager create-secret \
            --name ${DB_IDENTIFIER}-password \
            --secret-string "$DB_PASSWORD" 2>/dev/null || \
          aws secretsmanager update-secret \
            --secret-id ${DB_IDENTIFIER}-password \
            --secret-string "$DB_PASSWORD"
          
          echo "password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        else
          echo "Database already exists"
          # Retrieve password from Secrets Manager
          DB_PASSWORD=$(aws secretsmanager get-secret-value \
            --secret-id ${DB_IDENTIFIER}-password \
            --query 'SecretString' \
            --output text)
          echo "password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        fi
        
        # Get database endpoint
        DB_ENDPOINT=$(aws rds describe-db-instances \
          --db-instance-identifier $DB_IDENTIFIER \
          --query 'DBInstances[0].Endpoint.Address' \
          --output text)
        
        echo "endpoint=$DB_ENDPOINT" >> $GITHUB_OUTPUT
        echo "Database endpoint: $DB_ENDPOINT"
        
    - name: Setup Application Load Balancer
      id: alb
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸ”„ Setting up Application Load Balancer"
        echo "======================================"
        
        # Get VPC and subnets
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
        SUBNET_IDS=$(aws ec2 describe-subnets \
          --filters "Name=vpc-id,Values=$VPC_ID" \
          --query 'Subnets[?AvailabilityZone != `null`].SubnetId' \
          --output text | tr '\t' ' ')
        
        # Check if ALB exists
        ALB_EXISTS=$(aws elbv2 describe-load-balancers \
          --names $ALB_NAME \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$ALB_EXISTS" == "NOT_FOUND" ]]; then
          echo "Creating new ALB..."
          
          # Create security group for ALB
          ALB_SG_ID=$(aws ec2 create-security-group \
            --group-name ${ALB_NAME}-sg \
            --description "Security group for $ALB_NAME" \
            --vpc-id $VPC_ID \
            --query 'GroupId' \
            --output text)
          
          # Allow HTTP/HTTPS traffic
          aws ec2 authorize-security-group-ingress \
            --group-id $ALB_SG_ID \
            --protocol tcp \
            --port 80 \
            --cidr 0.0.0.0/0
          
          aws ec2 authorize-security-group-ingress \
            --group-id $ALB_SG_ID \
            --protocol tcp \
            --port 443 \
            --cidr 0.0.0.0/0 2>/dev/null || true
          
          # Create ALB
          ALB_ARN=$(aws elbv2 create-load-balancer \
            --name $ALB_NAME \
            --subnets $SUBNET_IDS \
            --security-groups $ALB_SG_ID \
            --scheme internet-facing \
            --type application \
            --ip-address-type ipv4 \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text)
          
          # Create target groups
          # Backend target group
          BACKEND_TG_ARN=$(aws elbv2 create-target-group \
            --name ${ENV_NAME}-backend-tg \
            --protocol HTTP \
            --port 8082 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-path / \
            --health-check-interval-seconds 30 \
            --health-check-timeout-seconds 10 \
            --healthy-threshold-count 2 \
            --unhealthy-threshold-count 3 \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          # Frontend target group
          FRONTEND_TG_ARN=$(aws elbv2 create-target-group \
            --name ${ENV_NAME}-frontend-tg \
            --protocol HTTP \
            --port 3000 \
            --vpc-id $VPC_ID \
            --target-type ip \
            --health-check-path / \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text)
          
          # Create HTTP listener with rules
          LISTENER_ARN=$(aws elbv2 create-listener \
            --load-balancer-arn $ALB_ARN \
            --protocol HTTP \
            --port 80 \
            --default-actions Type=fixed-response,FixedResponseConfig={StatusCode=404} \
            --query 'Listeners[0].ListenerArn' \
            --output text)
          
          # Store target group ARNs as outputs
          echo "backend_tg_arn=$BACKEND_TG_ARN" >> $GITHUB_OUTPUT
          echo "frontend_tg_arn=$FRONTEND_TG_ARN" >> $GITHUB_OUTPUT
          
          # Store target group ARNs in parameter store
          aws ssm put-parameter \
            --name /${ENV_NAME}/backend/target-group-arn \
            --value $BACKEND_TG_ARN \
            --type String \
            --overwrite
          
          aws ssm put-parameter \
            --name /${ENV_NAME}/frontend/target-group-arn \
            --value $FRONTEND_TG_ARN \
            --type String \
            --overwrite
        else
          echo "ALB already exists"
          # Get existing target group ARNs
          BACKEND_TG_ARN=$(aws ssm get-parameter \
            --name /${ENV_NAME}/backend/target-group-arn \
            --query 'Parameter.Value' \
            --output text)
          FRONTEND_TG_ARN=$(aws ssm get-parameter \
            --name /${ENV_NAME}/frontend/target-group-arn \
            --query 'Parameter.Value' \
            --output text)
          echo "backend_tg_arn=$BACKEND_TG_ARN" >> $GITHUB_OUTPUT
          echo "frontend_tg_arn=$FRONTEND_TG_ARN" >> $GITHUB_OUTPUT
        fi
        
        # Get ALB DNS name
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names $ALB_NAME \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
        
        echo "dns_name=$ALB_DNS" >> $GITHUB_OUTPUT
        echo "ALB DNS: $ALB_DNS"
        
    - name: Setup ALB Path-Based Routing
      id: routing
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸŒ Setting up ALB Path-Based Routing"
        echo "===================================="
        
        ALB_DNS="${{ steps.alb.outputs.dns_name }}"
        
        # Get listener ARN
        LISTENER_ARN=$(aws elbv2 describe-listeners \
          --load-balancer-arn $(aws elbv2 describe-load-balancers \
            --names $ALB_NAME \
            --query 'LoadBalancers[0].LoadBalancerArn' \
            --output text) \
          --query 'Listeners[0].ListenerArn' \
          --output text)
        
        # Update listener rules for path-based routing
        # Backend: /api/* -> backend target group
        aws elbv2 create-rule \
          --listener-arn $LISTENER_ARN \
          --priority 10 \
          --conditions Field=path-pattern,Values="/api/*" \
          --actions Type=forward,TargetGroupArn=${{ steps.alb.outputs.backend_tg_arn }} 2>/dev/null || \
        aws elbv2 modify-rule \
          --rule-arn $(aws elbv2 describe-rules \
            --listener-arn $LISTENER_ARN \
            --query 'Rules[?Conditions[?Field==`path-pattern`]].RuleArn | [0]' \
            --output text) \
          --conditions Field=path-pattern,Values="/api/*" \
          --actions Type=forward,TargetGroupArn=${{ steps.alb.outputs.backend_tg_arn }}
        
        # Frontend: /* -> frontend target group (default)
        aws elbv2 modify-listener \
          --listener-arn $LISTENER_ARN \
          --default-actions Type=forward,TargetGroupArn=${{ steps.alb.outputs.frontend_tg_arn }}
        
        echo "âœ… ALB Routing Configuration Complete"
        echo "ALB DNS: $ALB_DNS"
        echo "Backend API: http://$ALB_DNS/api"
        echo "Frontend: http://$ALB_DNS"
        
    - name: Store Infrastructure Details
      if: github.event.inputs.action != 'destroy'
      run: |
        echo "ðŸ’¾ Storing Infrastructure Details"
        echo "================================"
        
        # Store all infrastructure details in Parameter Store
        aws ssm put-parameter \
          --name /${ENV_NAME}/database/endpoint \
          --value "${{ steps.database.outputs.endpoint }}" \
          --type String \
          --overwrite
        
        aws ssm put-parameter \
          --name /${ENV_NAME}/alb/dns \
          --value "${{ steps.alb.outputs.dns_name }}" \
          --type String \
          --overwrite
        
        aws ssm put-parameter \
          --name /${ENV_NAME}/backend/url \
          --value "${{ steps.alb.outputs.dns_name }}/api" \
          --type String \
          --overwrite
        
        aws ssm put-parameter \
          --name /${ENV_NAME}/frontend/url \
          --value "${{ steps.alb.outputs.dns_name }}" \
          --type String \
          --overwrite
        
        echo "âœ… Infrastructure setup complete!"
        echo ""
        echo "ðŸŒ Access URLs:"
        echo "============="
        echo "Frontend: http://${{ steps.alb.outputs.dns_name }}"
        echo "Backend API: http://${{ steps.alb.outputs.dns_name }}/api"
        echo ""
        echo "ðŸ“ Note: The ALB DNS name is fixed and won't change on deployments"
        
    - name: Cleanup Infrastructure
      if: github.event.inputs.action == 'destroy'
      run: |
        echo "ðŸ—‘ï¸ Destroying Infrastructure"
        echo "==========================="
        
        # Delete RDS instance
        aws rds delete-db-instance \
          --db-instance-identifier $DB_IDENTIFIER \
          --skip-final-snapshot \
          --delete-automated-backups 2>/dev/null || echo "Database not found"
        
        # Delete ALB
        ALB_ARN=$(aws elbv2 describe-load-balancers \
          --names $ALB_NAME \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text 2>/dev/null || echo "NOT_FOUND")
        
        if [[ "$ALB_ARN" != "NOT_FOUND" ]]; then
          aws elbv2 delete-load-balancer --load-balancer-arn $ALB_ARN
        fi
        
        # Delete parameters
        aws ssm delete-parameter --name /${ENV_NAME}/database/endpoint 2>/dev/null || true
        aws ssm delete-parameter --name /${ENV_NAME}/backend/target-group-arn 2>/dev/null || true
        aws ssm delete-parameter --name /${ENV_NAME}/frontend/target-group-arn 2>/dev/null || true
        
        echo "âœ… Cleanup complete"