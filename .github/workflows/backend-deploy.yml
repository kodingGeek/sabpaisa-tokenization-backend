name: Backend Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: ap-south-1
  JAVA_VERSION: 17

jobs:
  deploy:
    name: Deploy Backend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'corretto'
          cache: 'maven'
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get database configuration
        id: db-config
        run: |
          echo "Getting database configuration..."
          
          # Get RDS endpoint
          DB_HOST=$(aws rds describe-db-instances \
            --db-instance-identifier sabpaisa-tokenization-${{ github.event.inputs.environment }} \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$DB_HOST" ] || [ "$DB_HOST" = "None" ]; then
            echo "Warning: Database not found, using placeholder"
            DB_HOST="localhost"
          fi
          
          echo "Database host: $DB_HOST"
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          
          # Get password from Secrets Manager
          DB_PASSWORD=$(aws secretsmanager get-secret-value \
            --secret-id sabpaisa-tokenization-${{ github.event.inputs.environment }}-db-password \
            --query SecretString \
            --output text 2>/dev/null || echo "password")
          
          echo "::add-mask::$DB_PASSWORD"
          echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
      
      - name: Create application properties
        run: |
          echo "Creating application properties..."
          
          mkdir -p src/main/resources
          
          cat > src/main/resources/application.properties << EOF
          spring.profiles.active=${{ github.event.inputs.environment }}
          spring.datasource.url=jdbc:postgresql://${{ steps.db-config.outputs.db_host }}:5432/sabpaisa_tokenization
          spring.datasource.username=postgres
          spring.datasource.password=${{ steps.db-config.outputs.db_password }}
          spring.datasource.driver-class-name=org.postgresql.Driver
          spring.jpa.hibernate.ddl-auto=validate
          spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
          spring.jpa.properties.hibernate.default_schema=tokenization
          server.port=8080
          server.servlet.context-path=/api
          logging.level.com.sabpaisa=INFO
          management.endpoints.web.exposure.include=health,info
          management.endpoint.health.show-details=always
          EOF
          
          echo "Application properties created"
      
      - name: Build application
        run: |
          echo "Building application..."
          echo "Current directory:"
          pwd
          echo "Files in current directory:"
          ls -la
          echo "Checking pom.xml:"
          cat pom.xml | head -20
          echo "Starting build:"
          mvn clean package -DskipTests -e
          
          # Check if WAR was created
          if [ ! -f target/*.war ]; then
            echo "Build failed - WAR file not found!"
            exit 1
          fi
          
          WAR_FILE=$(ls target/*.war | head -1)
          echo "Build successful: $WAR_FILE"
          ls -lh target/*.war
      
      - name: Find EC2 instance
        id: find-instance
        run: |
          echo "Finding backend EC2 instance..."
          
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=sabpaisa-backend-${{ github.event.inputs.environment }}" \
              "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          
          if [ "$INSTANCE_ID" = "None" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Backend EC2 instance not found!"
            echo "Please ensure the infrastructure is deployed first"
            exit 1
          fi
          
          echo "Found instance: $INSTANCE_ID"
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          
          # Get public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query "Reservations[0].Instances[0].PublicIpAddress" \
            --output text)
          
          echo "Public IP: $PUBLIC_IP"
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
      
      - name: Upload WAR to S3
        run: |
          echo "Uploading WAR to S3..."
          
          WAR_FILE=$(ls target/*.war | head -1)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          
          # Upload with timestamp
          aws s3 cp "$WAR_FILE" "s3://sabpaisa-artifacts/${{ github.event.inputs.environment }}/backend/app-$TIMESTAMP.war"
          
          # Upload as latest
          aws s3 cp "$WAR_FILE" "s3://sabpaisa-artifacts/${{ github.event.inputs.environment }}/backend/app-latest.war"
          
          echo "WAR uploaded successfully"
      
      - name: Deploy to EC2
        id: deploy
        run: |
          echo "Deploying to EC2 instance..."
          
          # Send deployment commands via SSM
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ steps.find-instance.outputs.instance_id }} \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "echo \"Starting deployment...\"",
              "sudo mkdir -p /opt/tomcat/logs",
              "sudo mkdir -p /opt/tomcat/webapps",
              "aws s3 cp s3://sabpaisa-artifacts/${{ github.event.inputs.environment }}/backend/app-latest.war /tmp/app.war",
              "sudo systemctl stop tomcat || true",
              "sleep 5",
              "sudo rm -rf /opt/tomcat/webapps/ROOT*",
              "sudo cp /tmp/app.war /opt/tomcat/webapps/ROOT.war",
              "sudo chown tomcat:tomcat /opt/tomcat/webapps/ROOT.war || true",
              "sudo systemctl start tomcat || (sudo /opt/tomcat/bin/startup.sh)",
              "echo \"Waiting for application to start...\"",
              "sleep 30",
              "curl -f http://localhost:8080/api/actuator/health || curl -f http://localhost:8080/api/health || echo \"Health check failed but continuing\"",
              "echo \"Deployment completed\""
            ]' \
            --output text \
            --query "Command.CommandId")
          
          echo "SSM Command ID: $COMMAND_ID"
          echo "command_id=$COMMAND_ID" >> $GITHUB_OUTPUT
          
          # Wait for command to complete (with timeout)
          echo "Waiting for deployment to complete..."
          aws ssm wait command-executed \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.find-instance.outputs.instance_id }} || true
          
          # Get command status
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ steps.find-instance.outputs.instance_id }} \
            --query "Status" \
            --output text)
          
          echo "Deployment status: $STATUS"
          echo "status=$STATUS" >> $GITHUB_OUTPUT
      
      - name: Get deployment output
        if: always()
        run: |
          echo "Getting deployment output..."
          
          # Get standard output
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id ${{ steps.deploy.outputs.command_id }} \
            --instance-id ${{ steps.find-instance.outputs.instance_id }} \
            --query "StandardOutputContent" \
            --output text || echo "No output available")
          
          echo "=== Deployment Output ==="
          echo "$OUTPUT"
          
          # Get error output if any
          ERROR=$(aws ssm get-command-invocation \
            --command-id ${{ steps.deploy.outputs.command_id }} \
            --instance-id ${{ steps.find-instance.outputs.instance_id }} \
            --query "StandardErrorContent" \
            --output text || echo "")
          
          if [ -n "$ERROR" ] && [ "$ERROR" != "None" ]; then
            echo "=== Error Output ==="
            echo "$ERROR"
          fi
      
      - name: Deployment Summary
        if: success()
        run: |
          echo "## âœ… Backend Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Instance ID**: ${{ steps.find-instance.outputs.instance_id }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Public IP**: ${{ steps.find-instance.outputs.public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Application URLs" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check**: http://${{ steps.find-instance.outputs.public_ip }}:8080/api/health" >> $GITHUB_STEP_SUMMARY
          echo "- **API Base**: http://${{ steps.find-instance.outputs.public_ip }}:8080/api" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Test the health endpoint" >> $GITHUB_STEP_SUMMARY
          echo "2. Configure security groups if needed" >> $GITHUB_STEP_SUMMARY
          echo "3. Set up monitoring and logging" >> $GITHUB_STEP_SUMMARY